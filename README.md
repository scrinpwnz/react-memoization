## Мемоизация в реакте
>**Мемоизация** (запоминание, от англ. memoization) — в программировании сохранение
результатов выполнения функций для предотвращения повторных вычислений.
Это один из способов оптимизации, применяемый для увеличения скорости
выполнения компьютерных программ. Перед вызовом функции проверяется,
вызывалась ли функция ранее:
>
>* если не вызывалась, то функция вызывается, и результат её выполнения сохраняется;
>* если вызывалась, то используется сохранённый результат.<br>
>
>[Статья на вики](https://ru.wikipedia.org/wiki/Мемоизация)
>

В Реакте для мемоизации используются 3 метода:
 * `React.memo`
 * `React.useMemo`
 * `React.useCallback`
___
### `React.memo`
`React.memo` — компонент высшего порядка (*High Order Component - HOC*), который позволяет мемоизировать компоненты.
Его следует использовать если компонент всегда рендерит одинаковый результат для одних и тех же пропсов. Это значит,
что **React** будет использовать результат последнего рендера, избегая повтороного рендеринга.
```
const MyComponent = React.memo(function MyComponent(props) {
    /* рендер с использованием пропсов */<br>
});
```
Если компонент использует `useState` или `useContext`, он будет повторно рендерится при изменении состояния или
контекста.
<br><br>
По умолчанию `React.memo` поверхностно сравнивает вложенные объекты в объекте `props`.<br>
Вторым аргументом в `React.memo` можно передать свою функцию сравнения.

###Пример

```
const App = () => {
    const [count1, setCount1] = React.useState(0)
    const [count2, setCount2] = React.useState(0)

    const increaseCounter1 = () => {
        setCount1(count1 => count1 + 1)
    }

    return (
        <>
            <button onClick={increaseCounter1}>Increase counter 1</button>
            <Counter value={count1}>Counter 1</Counter>
            <Counter value={count2}>Coutner 2</Counter>
        </>
    )
}
```








